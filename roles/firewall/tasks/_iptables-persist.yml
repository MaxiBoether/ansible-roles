# This file might appear a bit complicated but all the stunts we do in
# here serve the purpose of:
# a) creating a backup of the previous rules file,
# b) checking if the newly created rules file differs from the one backed
#    up,
# c) remove the backup if the rules did not change.
#
# During this procedure, almost all tasks would normally appear as
# "changed", even if nothing would actually be changed in the end.
# In order to have a clean summary at the end of running the Playbook,
# we force all tasks to be never ``changed_when`` and use only a single,
# custom task which indicates if the rules did actually change.

- name: backup currently persisted rules
        (task always unchanged, see below)
  command: "cp {{ rules_file|quote }} {{ rules_backup_file|quote }}"
  changed_when: false

- name: persist current rules
        (task always unchanged, see below)
  shell: "{{ dump_command|quote }} > {{ rules_file|quote }}"
  changed_when: false

- name: get contents backup and current file of persisted rules
        (task always unchanged, see below)
  register: persisted_rules_result
  shell: 'grep -v "^#" {{ item|quote }}
          | sed -r "s/(.*) \[[0-9]+:[0-9]+\](.*)/\1\2/g"'
  with_items:
    - "{{ rules_file }}"
    - "{{ rules_backup_file }}"
  changed_when: false

- name: remove backup if rules are unchanged
        (task always unchanged, see below)
  file:
    path: "{{ rules_backup_file }}"
    state: absent
  when: persisted_rules_result.results.0.stdout ==
        persisted_rules_result.results.1.stdout
  changed_when: false

- name: check if persisted rules changed
  debug:
    msg: "rules from ``{{ dump_command }}``{{ 'unchanged' if
                   persisted_rules_result.results.0.stdout ==
                   persisted_rules_result.results.1.stdout
                   else 'changed' }}"
  changed_when: persisted_rules_result.results.0.stdout !=
                persisted_rules_result.results.1.stdout
